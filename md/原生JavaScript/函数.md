# 函数

> 什么是JS中的函数？可以通过函数的三种角色来阐明：
1. 普通函数：当方法运行的时候，形成一个私有作用域，然后
        `形参赋值`，`预解释`，`JS代码逐行执行。`
2.  构造函数（类），new+首字母大写的函数名，构造函数里有自己的原型对象（prototype），构造函数里通过this。xx==xx设置的属性都是实例的私有属性，this就表示某一个实例，hasOwnProperty可以判断是私有属性还是公有的属性。
3. 函数也是对象，只是函数比较特殊，因此单独成function类型，
                `  fn instanceofof Object--》true`，可以像对象一样设置自己的属性和值。
>+ 这三种角色之间相互独立，没有关系。
>+ 所有的函数都是Function（构造函数）类的实例，
>+ 所有的对象都是Object类的实例。  任何对象（new 出来实例）最终都通过__proto__找到Object；

### 声明函数和匿名函数的区别
```
  var creatSth=1;
    function creatSth(){
        return 2;
    }
    console.log(creatSth);//1，因为此时上面的function是声明函数，根据预解释机制，已经声明过的不会再声明，所以返回1.
    var creatSth=function(){
        return 3;
    }
    console.log(creatSth);//3，这个返回的function是匿名函数，但整个式子是函数表达式，在JS执行过程中会覆盖之前的同名变量。
```
### 预解释：变量提升
当前作用域下，代码执行之前，对带`var`或`function`关键字的提前声明和定义。
JS中的内存按照功能的不同
`1,栈内存，提供了一个供JS代码执行的环境，全局作用域，私有作用域。`
`2，堆内存，引用数据类型的值）函数代码字符串）对象类型的键值对）`

>+ 首先，页面加载的时候，浏览器会提供一个供JS代码执行的环境--》`全局作用域`
 1，最外层`var`，最外层`function`
 2，所有`未定义直接赋值的变量`自动声明为拥有全局作用域
 3   所有`window对象`的属性拥有全局作用域 

**var关键字**的，在预解释的时候是声明，declare； 
```
  var  num=12; //1,全局作用域声明变量sum=12，在全局环境下会预解释。并增加window属性window.num=12,
num2=12、//仅仅是window.num2=12,
//此外：
var str='xiaomi'
//执行步骤：1，在代码执行之前，声明一个变量str；（预解释）也相当于给window增加了一个属性，但是没有值。
//2，在代码执行的时候，开辟一个内存空间，保存xiaomi这个数值。
//3，把xiaomi这个数据赋值给变量str，值和变量关联起来，
```
 **function**
 预解释的时候是`定义=声明+初始化`。包括开辟内存空间。
 `运行`的时候，也会提供一个供JS代码执行的环境--》`私有作用域`。称之为**闭包，** ,可以保护方法体里的内容不受外界的污染（干扰，），是一种**保护机制**。
 - `作用`：1防止变量名冲突，2，通过传参的方式，对全局变量在私有作用域里重新赋值。
 - 如果想把外界的变量传到闭包中：通过`传参`的方式，对全局变量在私有作用域中重新赋值。
 - 把闭包里的值传到外面   ：可以通过给`window添加属性`的方式。2，`return`，外面设置一个变量接受return的值。
 -  `定义`：1，开辟内存空间，2，将方法体内容以字符串形式存在内存中，3，将引用地址赋值给方法名。此时，方法名代表整个方法。
 -  `运行`：若有`形参`，先行给形参赋值。然后`预解释`。最后按如下将代码自上倒下执行。
            1，重新开辟一个内存空间（栈内存）。
            2 ，将方法体内的字符串变成js语句。
            3，每运行一次就会开辟一个封闭的内存空间。这就是闭包。起保护作用，
            4，return xxx，把方法运行的结果返回给变量xxx，
              `tips： `  
               1，如果没写return或者return后面没有返回值，方法的返回值就是`undefined。`
                    2，遇到return，方法终止，后面的代码不在运行。
                    3，return并不是一定要写，如果需要返回值就必须写。

>+ 如何`查找上级作用域，`
1，先判断当前函数是在哪个作用域下定义的，上一级作用域就是哪个。和方法在哪里执行无关。
2，查找过程形成`作用域链`，保证函数里的私有变量可以有序访问。
3，下级作用域可以查找相应上一层的作用域。反之则不能。即`可以从里往外，反之不行。`

>+ 函数`不进行预解释`的情况：
- 方法当值存在时，不预解释,即声明函数的时候。
       或者可以说：变量声明，只走=左边（如果把函数赋值给变量，按变量值来声明，）=右边不预解释。
- 自执行函数，定义+执行一起做了，也不预解释
    (function () {
    })()
- 不管if条件是否成立，都走预解释。
- 函数这边，return    后面的函数，不进行预解释。
                                   下面的代码  不再执行，但是var和function会预解释。
- 重名变量变量名字重复的话，不重复声明，在预解释的时候只会声明（预解释）一次，后面只是多次的赋值。
```
    var creatSth=1;
    function creatSth(){
        return 2;
    }
    console.log(creatSth);//1，因为此时上面的function是声明函数，根据预解释机制，已经声明过的不会再声明，所以返回1.
    var creatSth=function(){
        return 3;
    }
    console.log(creatSth);//3，这个返回的function是匿名函数，但整个式子是函数表达式，在JS执行过程中会覆盖之前的同名变量。
```
     
### 内存释放

##### 堆内存，引用数据类型的值、函数代码字符串、对象类型的键值对、
**引用数据类型**在定义的时候都会`开辟一个堆内存`并引用地址,,如果外面有变量等`知道`了这个地址,我们就说这个内存被`占用`了,就不能销毁.
```
普通变量和对象
    var obj={'a':11,'b':22};
    var num=12;  ///只有页面被关闭的时候，这两个变量才能被释放掉。
    obj=null;//当前堆内存没有任何东西被占用.
    num=null;//浏览器在空闲的时候，会寻找空指针（空引用）并释放。
高程3 最后一章.内存释放机制.
```

##### 栈内存,提供了一个供JS代码执行的环境，全局作用域，私有作用域。
>+ 全局作用域//不销毁,只有在页面关闭的时候,才销毁.
>+ 私有作用域,//只有函数执行才会产生私有作用域   
 -  一般情况下,函数执行会形成一个新的私有作用域,当私有作用域中的代码执行完成后,我们当前作用域都会`主动`的进行释放和销毁.
 - 特殊情况下,当前私有作用域中的部分内存被`作用域以外的东西`占用了,当前这个作用域就不能销毁了.
                   a)函数执行返回了一个引用数据类型的值,并且在函数的外面被一个其他的东西给接收了,这种情况下一般形成的私有作用域不销毁
    通过DOM方法获取的元素/元素集合都是对象类型的的值..
                    b)在一个私有的作用域中，给DOM元素的`事件绑定方法`，一般情况下私有作用域不销毁。
                   c)下述情况不立即销毁:f返回的函数没有被其他东西占用，但是还需要执行一次，`暂时`不销毁，当返回的值执行完成后，浏览器会在空闲的时候把它销毁。

### 回调函数：
 把一个函数作为`一个参数的值`传递给另外一个函数。在另外一个函数中，把传递进来的函数执行一次或者多次。
>+ 优点：-
- 节省变量名占用，特别是全局变量，
- 委托函数调用操作，节省代码，
- 性能（例如合并函数，减少循环）。
- 根据需求调整代码。

>+ 可以在A函数中尽情操作B函数，
>+ 还可以在A函数中的任何位置执行B函数N次。
>+ 并且还可以给B函数传递对应参数值。
>+ 不仅仅可以传递相应参数值，还可以修改回调函数中的this指向。默认的是window。
>+ 不仅仅可以改变this，还可以接受回调函数执行的返回值。

##### forEach	
用来`遍历`数据中的每一项的，它的第一个参数值是一个回调函数a。  第二个参数是将执行体中的`this`指向的修改。
- 数组中有几项，我们就让这个匿名回调函数执行几次。
- 不仅仅执行了了a，还可以给a传递三个参数值。item：数组当前这一项的值；index，索引，input原始数组。
-  默认情况下，forEach方法并没有改变回调函数中的this指向，默认的this依然是window。forEach支持第二个参数值，第二个参数值都是让回调函数a中的this变为第二个参数的值。
- forEach方法仅仅是用来遍历数组中的每一项的，它本身并不支持返回值（所以用一个变量接受他的返回值是undefined），它的回调函数中写return，对程序本身无影响。
- 封装并兼容IE678
```
 Array.prototype.myForEach = function myForEach() {
        var callback = arguments[0], context = arguments[1] || window;
        if (typeof callback !== "function") {
            return;
        }
        if ("forEach" in Array.prototype) {
            this.forEach(callback, context);
            return;
        }
        //->IE6~8
        for (var i = 0, len = this.length; i < len; i++) {
            callback.call(context, this[i], i, this);
        }
    };
```
**map**：和forEach基本操作一模一样，但是map是`支持返回值`的，在匿名回调函数中return的是啥，都相当于把当前数组中的这一项改变为啥，可以用来根据原数组生成新数组。原数组不变。

### 一些有关函数的小知识：
>+ 括号表达式:
一个小括号中有多项,中间用逗号隔开,我们最后获取的只是最后一项
(fn1, fn2)(); ->只把fn2执行了

>+ eval("12,23,34,45,56");//->(12,23,34,45,56) ->56 首先转换成JS表达式,但是表达式本身又是一个括号表达式,所以最后获取的总是最后一项
>+ 自执行函数，或者eval有多个括号，会一直走。eval('alert')('x')--》会执行ale

>+ 请尽量避免使用Function（）eval（）setTimeout（）进行函数构造，他们会把括号中的内容以字符串形式通过js代码检测。